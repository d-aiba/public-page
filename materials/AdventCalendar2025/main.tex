%----------
%----------
%----------
\title{述語変換子意味論と余代数}
% \author{饗庭 大地 (Aiba, Daichi)}
\author{こっとん (\href{https://twitter.com/CottonShampoo}{@CottonShampoo}) }
\date{2025年12月20日 土曜日}
%----------
\documentclass[
		% book,
		head_space=20mm,
		foot_space=20mm,
		gutter=10mm,
		line_length=190mm
]{jlreq}
%----------
\input 0_preamble.tex
\usepackage{docmute} %ファイル分割
%----------
\usepackage{stmaryrd}

\begin{document}


\maketitle %タイトル

\vspace{2mm}

\begin{screen}
	\begin{center}
		\href{https://adventar.org/calendars/11397}{Mathematical Logic Advent Calendar 2025}\\の20日目の投稿です。
	\end{center}
\end{screen}

\vspace{4mm}

\begin{screen}
	\begin{center}
		このドキュメントは，見やすく読みまちがえにくい\\ユニバーサルデザインフォントを採用しています。
	\end{center}
\end{screen}

\vspace{3mm}

\tableofcontents %目次


%----------
% \setcounter{part}{-1}
% \setcounter{chapter}{-1}
% \renewcommand{\thepart}{\arabic{part}}
% \renewcommand{\thesection}{\arabic{section}}
\setcounter{section}{-1}
%----------


\clearpage


\section{前置き}

\subsection{この記事が想定する対象読者}


\subsection{この記事の4つの目標}

この記事では、以下の4つのことを目標とします。

\begin{enumerate}
	\item 
	\item 
	\item 
	\item 
\end{enumerate}

% \vspace{3mm}

\subsection{この記事では扱わないこと}


% \vspace{5mm}

\clearpage

\section{ホーア論理と述語変換子}

\textbf{ホーア論理} (Hoare logic) と\textbf{述語変換子} (predicate transformer) は、プログラムの正しさ（意図した挙動をするか、バグがないかどうか）を数学的に検証するための、異なる2つのアプローチです。プログラムの満たしていてほしい性質（仕様）を論理式で記述し、それが満たされているかを論理学的手法を用いて確かめます。

たとえば、以下のような「入力 $N$ に対し、階乗 $N!$ を計算して出力するプログラム」を考えてみましょう。
\begin{framed}
	\begin{verbatim}
		n := N
		k := 1
		while (n>0) {
				k := k*n;
				n := n-1;
		}
	\end{verbatim}
	~\\[-48pt]
\end{framed}

$N$に正の自然数を入力してこのプログラムを実行した後に、事後条件「$k=N!$」を満たしてほしいものとします。ループが何回実行されるかわからない中で、あらゆる入力 $N$ に対してどうやって保証すればよいでしょうか。答えは、各回のループを通過する前後でいつも保存される条件（ループ不変量）「$k\cdot n!=N!$」に注目する、というものです。そうすることで「階乗を出力する」という仕様が必ず満たされることを保証できます。つまり、事後条件を保証するためには、ループ不変量を探せばよいのです。これが\textbf{ホーア論理}の考え方です。

では今度は、この事後条件「$k=N!$」を成り立たせるためには事前条件として何を課す必要があるか、という問題を考えてみましょう。答えは、「$N\geq 0$」です。これを求めるには、事後条件から出発してプログラムを後ろから前へたどり、各代入に応じて条件を置き換える、という操作をする必要があります。ただし、ループは何回実行されるかわからないので、この操作について不動点をとる必要があります。これが\textbf{述語変換子}の考え方です。

\subsection{ホーア論理}

ホーア論理では $\{P\}\,C\,\{Q\}$ という三つ組を使います。これは「事前条件$P$から始めて、プログラム$C$を実行した結果、事後条件$Q$が成り立つ」という関係です。

\begin{definition}
	ホーア論理の導出規則は以下のものからなる。
	\begin{center}	
		\AXC{} \RL{skip}
		\UIC{$\{A\}$ skip $\{A\}$}
		\DisplayProof
		\vspace{12pt}\\
		%%
		\AXC{} \RL{assignment}
		\UIC{$\{A\,[a/x]\}$ $x:=a$ $\{A\}$}
		\DisplayProof
		\vspace{12pt}\\
		%%%
		\AXC{$\{A\}\,P_1\,\{C\}$}
		\AXC{$\{C\}\,P_2\,\{B\}$} \RL{sequential composition}
		\BIC{$\{A\}\,P_1;P_2\,\{B\}$}
		\DisplayProof
		\vspace{12pt}\\
		%%% 
		\AXC{$\{A\land b\}\,P_1\,\{B\}$}
		\AXC{$\{A\land\lnot b\}\,P_2\,\{B\}$} \RL{if}
		\BIC{$\{A\}$ if $b$ then $P_1$ else $P_2$ $\{B\}$}
		\DisplayProof
		\vspace{12pt}\\
		%%%
		\AXC{$\{A\land b\} \,P\, \{A\}$} \RL{while}
		\UIC{$\{A\}$ while $b$ do $P$ $\{A\land\lnot b\}$}
		\DisplayProof
		\vspace{12pt}\\
		%%% 
		\AXC{$A\Rightarrow A'$}
		\AXC{$\{A'\}\,P\,\{B'\}$}
		\AXC{$B'\Rightarrow B$}
		\RL{consequence}
		\TIC{$\{A\}\,P\,\{B\}$}
		\DisplayProof
	\end{center}
\end{definition}

\begin{example}
	たとえば
	\begin{prooftree}
		\AXC{$\substack{x\geq 0 \land x > 0\\\Rightarrow\; x-1\geq 0}$}
		\AXC{}\RL{a}
		\UIC{$\substack{\{x-1\geq 0\}\; x:=x-1 \; \{x\geq 0\} }$} \RL{c}
		\BIC{$\substack{ \{ x\geq 0 \land x > 0\} \; x:=x-1 \; \{x\geq 0\} }$}
		%%%
		\AXC{$\substack{x\geq 0\land \lnot(x>0)\\\Rightarrow\; x\geq 0}$} 
		\AXC{}\RL{a}
		\UIC{$\substack{ \{x\geq 0\}\; x:=x\;\{x\geq 0\} }$} \RL{c}
		\BIC{$\substack{ \{x\geq 0\land\lnot(x>0)\}\; x:=x\; \{x\geq 0\} }$} \RL{i}
		\BIC{$\substack{ \{x\geq 0\} \; \textrm{if } x>0 \textrm{ then } x:=x-1  \textrm { else } x:=x \; \{x\geq 0\} }$}
	\end{prooftree}
\end{example}

% % \begin{example}
% % 	たとえば、冒頭の「階乗を計算するプログラム」のホーア論理による証明図は以下の通り。
% 	\begin{prooftree}
% 		\AXC{$\substack{N\geq 0\\\Rightarrow k\cdot n!=N!}$}
% 		% \AXC{$\substack{\{k\cdot n!=N!\land n>0\}\, k:=k\cdot n\,;\,n:=n-1\,\{k\cdot n!=N!\}}$}
% 		\AXC{$\substack{\{k\cdot n!=N!\,\land\,n>0\}\,k:=k\cdot n\,;\,n:=n-1\,\{k\cdot n!=N!\}}$}
% 		\RL{w}
% 		\UIC{$\substack{\{k\cdot n!=N!\}\,\textrm{while}\,(n>0)\,k:=k\cdot n\,;\,n:=n-1\,\{k\cdot n!=N!\,\land\,n=0\}}$}
% 		\AXC{$\substack{k\cdot n!=N!\,\land\, n=0\\\Rightarrow k=N!}$}
% 		\RL{c}
% 		\TIC{$\substack{\{N\geq 0\}\,\textrm{while}\,(n>0)\, k:=k\cdot n\,;\,n:=n-1\,\{k=N!\}}$}
% 	\end{prooftree}
% 	\begin{prooftree}
% 		\AXC{$\substack{\{N\geq 0\}\,n:=N\,\{n\geq 0\,\land\,n!=N!\}}$}
% 		\AXC{$\substack{\{n\geq 0\,\land\,n!=N!\}\,k:=1\,\{n\geq 0\,\land\,k\cdot n!=N!\}}$}
% 		\AXC{}
% 		\UIC{$\substack{\{n\geq 0\,\land\,k\cdot n!=N!\}\,\textrm{while}\,(n>0)\, k:=k\cdot n\,;\,n:=n-1\,\{k\cdot n!=N!\land n=0\}}$}
% 		\AXC{$\substack{k\cdot n!=N!\,\land\, n=0\\\Rightarrow k=N!}$}
% 		\BIC{$\substack{\{n\geq 0\,\land\,k\cdot n!=N!\}\,\textrm{while}\,(n>0)\, k:=k\cdot n\,;\,n:=n-1\,\{k=N!\}}$}
% 		\TIC{$\substack{\{N\geq 0\}\,n:=N\,;\,k:=1\,;\,\textrm{while}\,(n>0)\, k:=k\cdot n\,;\,n:=n-1\,\{k=N!\}}$}
% 	\end{prooftree}
% % \end{example}

\begin{remark}
	ループ不変量とは、以下のような while 文の証明図に現れる $I$ のこと。つまり、
	% (1) ループの入り口で事前条件によって含意され（$A\Rightarrow I$）、(2) 各回のループの実行時に常に保たれ（$\{I\land\varphi\}\,C\,\{I\}$）、(3) ループの出口で事後条件を含意する（$I\land\lnot\varphi\Rightarrow B$）
	\begin{enumerate}
		\item ループの\kenten{入口}で事前条件によって含意され（$A\Rightarrow I$）、
		\item 各回のループ\kenten{実行時}に常に保たれ（$\{I\land\varphi\}\,C\,\{I\}$）、
		\item ループの\kenten{出口}で事後条件を含意する（$I\land\lnot\varphi\Rightarrow B$）
	\end{enumerate}
	ような論理式$I$のことである。\vspace{5pt}
	\begin{prooftree}
		\AXC{$A\Rightarrow I$}
		\AXC{$\{I\land \varphi\}\,C\,\{I\}$} \RL{while}
		\UIC{$\{I\}\,\textrm{while}\;\varphi\;\textrm{do}\;C\,\{I\land\lnot\varphi\}$}
		\AXC{$I\land \lnot \varphi\Rightarrow B$} \RL{conseq}
		\TIC{$\{A\}\,\textrm{while}\;\varphi\;\textrm{do}\;C\,\{B\}$}
	\end{prooftree}\vspace{5pt}
	先ほどの「階乗を計算するプログラム」のホーア論理による証明図を書くと（長くなるので省略するが）$I$のところに現れる論理式は「$k\cdot n!=N!$」となる。これが先ほどのプログラムの while 文の「ループ不変量」にあたる。
\end{remark}

\subsection{述語変換子}

述語変換子は、述語 $Q$ を別の述語 $wp\llbracket C\rrbracket (Q)$ に変換します。これは「プログラム$C$について、事後条件$Q$を成り立たせる事前条件のうち、論理的含意関係に関して最も弱いもの」、\textbf{最弱事前条件} (weakest precondition) です。

\begin{definition}[述語変換子意味論]
	状態集合を $S$ とする。$S$ 上の述語の集合を $\mathrm{Pred}(S)=\{Q\mid Q:S\to\{0,1\}\}$ と定める。なお、各述語 $Q:S\to\{0,1\}$ は、$Q=\{s\in S\mid s\models Q\}$ だと考えればよい。述語どうしの順序は、含意関係によって定めるものとする。そうすると、$(\mathrm{Pred}(S),\leq)$ は完備束をなす。\[P\leq Q \quad\textrm{iff}\quad P\Rightarrow Q\] プログラム $C$ の述語変換子 (predicate transformer) とは、写像 \[wp\llbracket C\rrbracket:\mathrm{Pred}(S)\to\mathrm{Pred}(S)\] であって単調性 $Q_1\leq Q_2 \;\Rightarrow\; wp\llbracket C\rrbracket(Q_1)\leq wp\llbracket C\rrbracket(Q_2)$ を満たすものである。具体的には以下のように帰納的に定義される。
	\begin{itemize}
		\item $wp\llbracket\textrm{skip}\rrbracket(Q)=Q$
		\item $wp\llbracket x:=a\rrbracket(Q)=Q[a/x]$
		\item $wp\llbracket C_1;C_2\rrbracket(Q)=wp\llbracket C_1\rrbracket(wp\llbracket C_2\rrbracket(Q))$
		\item $wp\llbracket\mathrm{if}\;\varphi\;\mathrm{then}\;C_1\;\mathrm{else}\;C_2\rrbracket(Q)=(\varphi\land wp\llbracket C_1\rrbracket(Q))\lor(\lnot\varphi\land wp\llbracket C_2\rrbracket(Q))$
		\item $wp\llbracket\mathrm{while}\;\varphi\;\mathrm{do}\;C\rrbracket(Q)=\mu X.\,\underbrace{((\varphi\land wp\llbracket C\rrbracket(X))\lor(\lnot\varphi\land Q))}_{\mathrm{loop~characteristic~function~} \Phi_Q(X)}$
	\end{itemize}
\end{definition}

\begin{remark}
	ここで $\mu$ は順序 $\leq$ についての最小不動点をとる操作である。$\Phi_Q:\mathrm{Pred}(S)\to\mathrm{Pred}(S)$ はスコット連続なので、クリーネの不動点定理より、$\displaystyle\mu X.\,\Phi_Q(X)=\bigvee_{n\in\mathbb N}\Phi_Q^n(\bot)$ が得られる。
\end{remark}

\clearpage

\noindent 以上のように、ホーア論理と述語変換子という2つのアプローチがあります。ここで両者を整理しておきましょう。
\[\begin{cases}\{P\}\,C\,\{Q\} & \textrm{Hoare-style}\\P\Rightarrow wp\llbracket C\rrbracket(Q) & \textrm{Dijkstra-style}\end{cases}\]
両者の関係としては、以下が同値になることが知られています。
\[\{P\}\,C\,\{Q\} \quad\;\textrm{iff}\;\quad P\Rightarrow wp\llbracket C\rrbracket(Q)\] 
より詳しく見ると、実は以下の違いがあります。
\begin{itemize}
	\item ホーア三つ組は「関係的」(relational)。 \\
	\quad 各述語 $P$ に対し、$\{P\}\,C\,\{Q\}$ が成り立つような述語 $Q$ は複数ありうる。\\
	\quad 各述語 $Q$ に対し、$\{P\}\,C\,\{Q\}$ が成り立つような述語 $P$ は複数ありうる。
	% \begin{itemize}
	% 	\item 各述語 $P$ に対し、$\{P\}\,C\,\{Q\}$ が成り立つような述語 $Q$ は複数ありうる。
	% 	\item 各述語 $Q$ に対し、$\{P\}\,C\,\{Q\}$ が成り立つような述語 $P$ は複数ありうる。
	% \end{itemize}
	\item 最弱事前条件は「関数的」(functional) \\
	\quad 各述語 $Q$ に対し、述語 $wp\llbracket C\rrbracket(Q)$ は一意に定まる。
	% \begin{itemize}
	% 	\item 各述語 $Q$ に対し、述語 $wp\llbracket C\rrbracket(Q)$ は一意に定まる。
	% \end{itemize}
\end{itemize}
他方、wp から Hoare triple を「再現」することができます。
\begin{itemize}
	\item $\{\,wp\llbracket C\rrbracket(Q)\,\}\,C\,\{Q\}$ はいつでも成り立つ。
\end{itemize}

さて、これら Hoare-style と Dijkstra-style には、それだけでなく、より本質的な違いがあります。それは、部分正当化 (partial correctness) か、全正当性 (total correctness) か、の違いです。

\subsection{部分正当性と全正当性}

プログラムの正しさを検証するうえで、\textbf{部分正当性} (partial correctness) と\textbf{全正当性} (total correctness) という2種類の「正しさ」の考え方があります。ホーア三つ組 $\{P\}\,C\,\{Q\}$ は前者（部分正当性）を主張するものです。ここではさしあたり、後者（全正当性）のほうを $[P]\,C\,[Q]$ と表記して区別することにして、両者の違いを比べてみましょう。
\begin{itemize}
	\item 部分正当性 (partial correctness) \;$\{P\}\,C\,\{Q\}$
	\begin{itemize}
		\item 「事前条件 $P$ から始めて、\kenten{もし}プログラム $C$ が\kenten{停止したら}、その実行結果は事後条件 $Q$ を満たす。」
		\item プログラムが停止しないときには何も保証しない。
	\end{itemize}
	\item 全正当性 (total correctness) \;$[P]\,C\,[Q]$
	\begin{itemize}
		\item 「事前条件 $P$ から始めて、プログラム $C$ が\kenten{必ず停止し}、\kenten{かつ}、その実行結果は事後条件 $Q$ を満たす。」
		\item プログラムの停止性 (termination) も保証する。
	\end{itemize}
\end{itemize}
ホーア三つ組は部分正当性 (partial correctness) なのに対し、述語変換子は全正当性 (total correctness) です。この違いは、while ループの不動点のとり方に端を発しています。述語変換子の while の意味論は、最小不動点で与えられていたことを思い出しましょう。
\[wp\llbracket\mathrm{while}\;\varphi\;\mathrm{do}\;C\rrbracket(Q)=\mu X.\,\underbrace{((\varphi\land wp\llbracket C\rrbracket(X))\lor(\lnot\varphi\land Q))}_{\mathrm{loop~characteristic~function~} \Phi_Q(X)}\]
それに対し、ホーア論理の while 文は、実は、最大不動点によって与えられていたのです！\vspace{5pt}
	\begin{prooftree}
		\AXC{$P\Rightarrow I$}
		\AXC{$\{I\land \varphi\}\,C\,\{I\}$} \RL{while}
		\UIC{$\{I\}\,\textrm{while}\;\varphi\;\textrm{do}\;C\,\{I\land\lnot\varphi\}$}
		\AXC{$I\land \lnot \varphi\Rightarrow Q$} \RL{conseq}
		\TIC{$\{P\}\,\textrm{while}\;\varphi\;\textrm{do}\;C\,\{Q\}$}
	\end{prooftree}\vspace{5pt}

\clearpage

\begin{proposition}
	$L$ を完備束とし、$f:L\to L$ を単調写像とする。このとき、以下の帰結関係（上から下）が成り立つ。\vspace{5pt}
	\begin{center}
	\begin{prooftree}
		\AXC{$p\leq i$} 
		\AXC{$i\leq f(i)$} 
		\AXC{$i\leq q$} 
		\TIC{$p\leq\nu(f(-)\land q)$}
	\end{prooftree}
	\end{center}
\end{proposition}

\begin{proof}
	$\land$ の普遍性より、以下の同値関係が成り立つ。
	\begin{prooftree}
		\AXC{$i\leq f(i)$}
		\AXC{$i\leq q$}
		\doubleLine
		\BIC{$i\leq f(i)\land q$}
	\end{prooftree}
	ナスター・タルスキの定理より、\[\nu(f(-)\land q)=\bigvee\{x\in L\mid x\leq f(x)\land q\}\] であるから、特に任意の $i\in L$ について以下の帰結関係が成り立つ。
	\begin{prooftree}
		\AXC{$i\leq f(i)\land q$}
		\UIC{$i\leq\nu(f(-)\land q)$}
	\end{prooftree}
	ここで、条件 $p\leq i$ と推移性から、最終的に
	\begin{prooftree}
		\AXC{$p\leq i$} 
		\AXC{$i\leq f(i)$} 
		\AXC{$i\leq q$} 
		\TIC{$p\leq\nu(f(-)\land q)$}
	\end{prooftree}
	が得られた。
\end{proof}

\noindent 
ここで、$p$ は事前条件、$q$ は事後条件、$i$ はループ不変量に、おおよそ相当しています。いま、
\begin{itemize}
	\item \fbox{\,$f(i)$\,} を \fbox{\,$\varphi\Rightarrow wp\llbracket C\rrbracket(I)$\,} に読み替える
	\item \fbox{\,$q$\,} を \fbox{\,$\lnot\varphi\Rightarrow Q$\,} に読み替える
\end{itemize}
とすれば、先ほどの while ループの規則に対応していることがわかりやすいのではないかと思います。\vspace{5pt}
\begin{center}
	% \begin{prooftree}
		\AXC{$p\leq i$} 
		\AXC{$i\leq f(i)$} 
		\AXC{$i\leq q$} 
		\TIC{$p\leq\nu(f(-)\land q)$}
		\DisplayProof
	% \end{prooftree}
	\qquad$\leadsto$\qquad
	% \begin{prooftree}
		\AXC{$P\Rightarrow I$}
		\AXC{$\{I\land \varphi\}\,C\,\{I\}$} %\RL{while}
		\UIC{$\{I\}\,\textrm{while}\;\varphi\;\textrm{do}\;C\,\{I\land\lnot\varphi\}$}
		\AXC{$I\land \lnot \varphi\Rightarrow Q$} %\RL{conseq}
		\TIC{$\{P\}\,\textrm{while}\;\varphi\;\textrm{do}\;C\,\{Q\}$}
	% \end{prooftree}\vspace{5pt}
		\DisplayProof
\end{center}\vspace{5pt}
あえて述語変換子の言葉に寄せると、以下のように書くこともできます。
\[P\Rightarrow\nu X.\,((\varphi\Rightarrow wp\llbracket C\rrbracket(X))\land(\lnot\varphi\Rightarrow Q))\]
つまり、同じものについて、ホーア論理では最大不動点 (gfp, $\nu$) を、最弱事前条件では最小不動点 (lfp, $\mu$) をとっていたことがわかります。（なお、述語変換子の中にも、while の部分正当化を行うものもあり、最弱リベラル事前条件 (weakest liberal precondition) と呼ばれます。）

以上のことをまとめると、以下の表の通りです。\\

\begin{center}
	\begin{tabular}{c|c|c}
		\hline
		& Hoare logic & predicate transformer \\ 
		\hline
		gfp & partial correctness & weakest liberal precondition \\
		\hline
		lfp & total correctness & weakest precondition \\ 
		\hline
	\end{tabular}
\end{center}
~\\

さて、この節で扱った述語変換子の考え方は、圏論的に扱うととても見通しがよくなります。そのための準備として、次節では、圏論の関手を使ってプログラムの振舞いを捉える方法について紹介します。

\clearpage

\section{圏論の関手でシステムの振舞いを捉える}

\clearpage

\section{最弱事前条件をどのように手に入れるか}

\clearpage

%-----
% \clearpage
\begin{thebibliography}{99}
    \item 
\end{thebibliography}
%-----


\end{document}